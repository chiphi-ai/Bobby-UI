<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Transcript ‚Äî Phi AI</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
  <style>
    .transcript-layout {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: var(--space-xl);
      align-items: start;
    }
    
    /* Make speakers sidebar sticky on the left - always visible */
    .transcript-layout > aside {
      position: sticky !important;
      top: 80px; /* Will be adjusted by JavaScript to account for header */
      align-self: start;
      max-height: calc(100vh - 100px); /* Will be adjusted by JavaScript */
      height: auto;
      overflow-y: auto !important;
      overflow-x: visible;
      z-index: 100 !important;
      /* Ensure it stays visible with solid background */
      background: var(--bg-primary) !important;
      /* Smooth scrolling for internal content */
      scrollbar-width: thin;
      scrollbar-color: var(--border-light) transparent;
    }
    
    /* Ensure parent containers don't break sticky */
    .transcript-layout {
      overflow: visible !important;
    }
    
    /* Ensure card-body doesn't break sticky positioning */
    .card-body {
      overflow: visible !important;
    }
    
    /* Ensure the card itself doesn't break sticky */
    .card.holo-border {
      /* backdrop-filter can break sticky, but we'll work with it */
      overflow: visible;
    }
    
    /* Spinner animation for loading states */
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    @media (max-width: 980px) {
      .transcript-layout { 
        grid-template-columns: 1fr; 
      }
      .transcript-layout > aside {
        position: relative;
        top: 0;
        max-height: none;
        overflow-y: visible;
      }
      #audioPlayerSection {
        padding: var(--space-sm) !important;
      }
      #audioPlayerSection audio {
        min-width: 0;
      }
    }
    
    /* Fixed Bottom Audio Player - Always Visible */
    .audio-player-bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      background: var(--bg-primary);
      padding: var(--space-md);
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
      border-top: 1px solid var(--border-light);
      border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0;
    }
    
    /* Restore backdrop-filter for card (no longer needed for sticky) */
    main.main-content .card.holo-border {
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(255, 255, 255, 0.82);
    }
    
    /* Restore card-body overflow */
    .card-body {
      overflow: auto;
    }
    .speaker-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }
    .speaker-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--space-xs);
      padding: var(--space-md);
      border: 1px solid var(--border-light);
      border-radius: var(--border-radius);
      background: var(--bg-secondary);
    }
    .speaker-row small { color: var(--text-secondary); }
    .speaker-row input {
      width: 100%;
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--border-radius-sm);
      border: 1px solid var(--border-light);
      background: var(--bg-primary);
      color: var(--text-primary);
    }
    .utterance {
      padding: var(--space-md);
      border: 1px solid var(--border-light);
      border-radius: var(--border-radius);
      background: var(--bg-secondary);
      margin-bottom: var(--space-md);
      transition: all var(--transition-fast);
      cursor: pointer;
    }
    .utterance:hover { transform: translateY(-1px); box-shadow: var(--shadow); background: var(--bg-primary); }
    .utterance-header {
      display: flex;
      justify-content: space-between;
      gap: var(--space-md);
      align-items: baseline;
      margin-bottom: var(--space-xs);
    }
    .speaker-chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-light);
      background: rgba(0, 122, 255, 0.08);
      color: var(--text-primary);
      font-weight: var(--font-weight-semibold);
      font-size: var(--font-size-sm);
    }
    .speaker-chip code { font-size: 11px; color: var(--text-secondary); background: transparent; }
    .conf-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-light);
      background: rgba(52, 199, 89, 0.10);
      color: var(--text-secondary);
      font-size: 12px;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
    .utterance-actions {
      display: inline-flex;
      gap: var(--space-xs);
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .word-span {
      display: inline;
      transition: all 0.2s ease;
      border-radius: 3px;
    }
    .word-span.word-active {
      background-color: rgba(0, 122, 255, 0.2) !important;
      font-weight: 600 !important;
      color: var(--accent) !important;
    }
    .word-mode-text {
      line-height: 1.8;
    }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 24px;
    }
    .modal {
      width: min(560px, 100%);
      border-radius: 16px;
      background: rgba(255,255,255,0.98);
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      overflow: hidden;
    }
    .modal-header {
      padding: 16px 18px;
      border-bottom: 1px solid rgba(0,0,0,0.08);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .modal-title { margin: 0; font-weight: 800; }
    .modal-body { padding: 18px; }
    .modal-footer { padding: 16px 18px; border-top: 1px solid rgba(0,0,0,0.08); display: flex; justify-content: flex-end; gap: 10px; }
    .modal input {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.12);
      background: white;
      color: var(--text-primary);
      font-size: 14px;
    }
    .timestamp {
      color: var(--text-secondary);
      font-size: var(--font-size-xs);
      font-variant-numeric: tabular-nums;
    }
    .top-actions {
      display: flex;
      gap: var(--space-sm);
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-lg);
    }
    .toast {
      position: fixed;
      bottom: 18px;
      right: 18px;
      padding: 12px 14px;
      border-radius: 12px;
      background: rgba(29, 29, 31, 0.92);
      color: white;
      font-size: 14px;
      display: none;
      z-index: 9999;
      max-width: min(420px, calc(100vw - 36px));
    }
  </style>
</head>
<body>
  <div class="bg-waves{% if waves_debug %} debug-mode{% endif %}" aria-hidden="true"></div>
  {% if waves_debug %}
  <div class="waves-debug-badge">üåä WAVES ON</div>
  {% endif %}

  <div class="app-container">
    <header class="header">
      <div class="header-inner">
        <a href="{{ url_for('account_home') }}" class="header-brand">
          <img src="{{ url_for('static', filename='images/logo.png.png') }}" alt="Phi AI" class="header-logo">
        </a>
        <nav class="header-nav">
          <a href="{{ url_for('account_home') }}" class="header-link">Dashboard</a>
          <a href="{{ url_for('account_meetings') }}" class="header-link active">Meetings</a>
          {% if phi_available %}
          <a href="{{ url_for('ask_get') }}" class="header-link">Ask Phi</a>
          {% else %}
            <a href="#" class="header-link" aria-disabled="true" title="Phi is starting up" onclick="return false;" style="opacity: 0.5; cursor: not-allowed;">Ask Phi</a>
          {% endif %}
          <a href="{{ url_for('connect_apps_get') }}" class="header-link">Connect Apps</a>
          <a href="{{ url_for('account_get') }}" class="header-link">Settings</a>
          <a href="{{ url_for('logout') }}" class="header-link">Logout</a>
        </nav>
      </div>
    </header>

    <main class="main-content enter">
      <div class="card holo-border enter enter-delay-1">
        <div class="card-header">
          <h2 class="card-title">Transcript ‚Äî {{ meeting.name or meeting_id }}</h2>
        </div>
        <div class="card-body">
          <div class="top-actions">
            <div style="display:flex; gap: var(--space-sm); flex-wrap: wrap;">
              <a href="{{ url_for('account_meetings') }}" class="btn btn-sm btn-secondary">‚Üê Back</a>
              <a href="{{ transcript_pdf_url }}" class="btn btn-sm btn-secondary" target="_blank">Transcript PDF</a>
            </div>
            <div style="display:flex; gap: var(--space-sm); flex-wrap: wrap; align-items: center;">
              <button id="generateAiSummaryBtn" class="btn btn-sm btn-secondary" title="Generate AI-powered meeting summary (may take several minutes)">ü§ñ Generate AI Summary</button>
              <button id="saveLabelsBtn" class="btn btn-sm btn-primary">Save speaker names</button>
            </div>
          </div>

          <!-- Spacer for audio player (prevents content from being hidden behind fixed player) -->
          <div id="audioPlayerSpacer" style="height: 140px; margin-bottom: var(--space-lg);"></div>

          <div class="transcript-layout">
            <aside class="card" style="padding: var(--space-lg);">
              <div style="display:flex; align-items:center; justify-content: space-between; gap: var(--space-sm); margin-bottom: var(--space-md);">
                <div style="font-weight: var(--font-weight-semibold);">Speakers</div>
                <button class="btn btn-sm btn-secondary" id="mergeHelpBtn" type="button">Merging?</button>
              </div>
              <div class="speaker-list" id="speakerList">
                {% for s in speakers %}
                <div class="speaker-row" data-speaker-raw="{{ s.raw }}">
                  <input
                    type="text"
                    value="{{ s.display }}"
                    placeholder="Enter speaker name"
                    data-speaker-input="{{ s.raw }}"
                    data-default-display="{{ s.display }}"
                  />
                </div>
                {% endfor %}
              </div>
              <div style="margin-top: var(--space-md); color: var(--text-secondary); font-size: var(--font-size-xs); line-height: 1.4;">
                To merge speakers: set multiple speakers to the same name (e.g. both become "Carter Magnano").
              </div>
              
              <!-- Re-run Diarization Controls -->
              <div style="margin-top: var(--space-lg); padding-top: var(--space-md); border-top: 1px solid var(--border-light);">
                <div style="font-weight: var(--font-weight-semibold); margin-bottom: var(--space-sm); font-size: var(--font-size-sm);">Adjust Speaker Count</div>
                <div style="display: flex; flex-direction: column; gap: var(--space-sm);">
                  <button type="button" class="btn btn-sm btn-primary" id="addSpeakersBtn" style="width: 100%;">
                    ‚ûï Add Speakers
                  </button>
                  <button type="button" class="btn btn-sm btn-secondary" id="removeSpeakersBtn" style="width: 100%; color: var(--error);">
                    ‚ûñ Remove Speakers
                  </button>
                </div>
                <div id="rerunStatus" style="margin-top: var(--space-sm); font-size: var(--font-size-xs); color: var(--text-secondary); display: none;">
                  <span class="spinner" style="display: inline-block; width: 12px; height: 12px; border: 2px solid var(--border-light); border-top-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite;"></span>
                  <span id="rerunStatusText">Re-running diarization...</span>
                </div>
                <div style="margin-top: var(--space-xs); color: var(--text-secondary); font-size: 11px; line-height: 1.3;">
                  Re-runs diarization with updated speaker count. This may take a few minutes.
                </div>
              </div>
            </aside>

            <section>
              {% for u in utterances %}
              <div class="utterance"
                   data-start="{{ u.start }}"
                   data-end="{{ u.end }}"
                   data-speaker-raw="{{ u.speaker_raw }}"
                   data-utterance-id="{{ u.utterance_id }}"
                   data-source-utterance-id="{{ u.source_utterance_id }}">
                <div class="utterance-header">
                  <div style="display:flex; align-items:center; gap: var(--space-sm); flex-wrap: wrap;">
                    <div class="speaker-chip" data-speaker-chip="{{ u.speaker_raw }}">
                      <span class="speaker-display">{{ u.speaker_display }}</span>
                    </div>
                    <div class="conf-badge" title="Approximate diarization confidence">
                      Conf: <span class="conf-val">{{ u.speaker_confidence_percent }}%</span>
                    </div>
                  </div>
                  <div class="utterance-actions">
                    <div class="timestamp">{{ '%.1f'|format(u.start) }}s</div>
                    <button type="button" class="btn btn-sm btn-secondary utterance-edit-btn" title="Edit transcript text">Edit</button>
                    <button type="button" class="btn btn-sm btn-secondary utterance-override-btn">New Speaker</button>
                    {% if u.utterance_id == u.source_utterance_id %}
                    <button type="button" class="btn btn-sm btn-secondary utterance-split-btn">Split</button>
                    {% else %}
                    <button type="button" class="btn btn-sm btn-secondary utterance-add-split-btn" data-source-utterance-id="{{ u.source_utterance_id }}">Add Split</button>
                    <button type="button" class="btn btn-sm btn-secondary utterance-undo-split-btn" data-source-utterance-id="{{ u.source_utterance_id }}">Undo Split</button>
                    {% endif %}
                  </div>
                </div>
                <div class="utterance-text" style="white-space: pre-wrap;" data-utterance-text="{{ u.text }}" data-has-words="{{ 'true' if u.words else 'false' }}">
                  {% if u.words %}
                    <span class="word-mode-text" style="display: none;">
                      {% for word in u.words %}
                        <span class="word-span" 
                              data-word-start="{{ word.start }}" 
                              data-word-end="{{ word.end }}"
                              data-word-index="{{ loop.index0 }}"
                              title="{{ '%.2f'|format(word.start) }}s - {{ '%.2f'|format(word.end) }}s">{{ word.word }}</span>{% if not loop.last %} {% endif %}
                      {% endfor %}
                    </span>
                    <span class="normal-mode-text">{{ u.text }}</span>
                  {% else %}
                    {{ u.text }}
                  {% endif %}
                </div>
              </div>
              {% endfor %}
            </section>
          </div>
        </div>
      </div>
    </main>
  </div>

  <div id="toast" class="toast"></div>

  <!-- New Speaker (per-utterance override) modal -->
  <div id="overrideModal" class="modal-overlay" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">New Speaker (this line only)</h3>
        <button type="button" class="btn btn-sm btn-secondary" id="overrideCloseBtn">Close</button>
      </div>
      <div class="modal-body">
        <div style="color: var(--text-secondary); font-size: 13px; margin-bottom: 10px;">
          This changes the name for just this utterance (it won‚Äôt rename the whole speaker).
        </div>
        <input id="overrideInput" type="text" placeholder="Enter speaker name (e.g., Mike)" maxlength="100" />
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" id="overrideCancelBtn">Cancel</button>
        <button type="button" class="btn btn-primary" id="overrideSaveBtn">Save</button>
      </div>
    </div>
  </div>

  <!-- Split utterance modal -->
  <div id="splitModal" class="modal-overlay" role="dialog" aria-modal="true">
    <div class="modal" style="max-width: 700px;">
      <div class="modal-header">
        <h3 class="modal-title">Split utterance at word</h3>
        <button type="button" class="btn btn-sm btn-secondary" id="splitCloseBtn">Close</button>
      </div>
      <div class="modal-body">
        <div style="color: var(--text-secondary); font-size: 13px; margin-bottom: 12px;">
          Click on a word below to select where to split. The split will occur <strong>before</strong> the selected word (the selected word will be the first word of the second part).
        </div>
        
        <!-- Word selection area -->
        <div id="splitWordSelection" style="padding: 20px; background: var(--bg-secondary); border-radius: var(--border-radius); margin-bottom: 16px; min-height: 80px; max-height: 250px; overflow-y: auto; border: 1px solid var(--border);">
          <div style="color: var(--text-secondary); font-size: 12px; text-align: center; padding: 20px;">
            Loading words...
          </div>
        </div>
        
        <!-- Selected word info -->
        <div id="splitSelectedWordInfo" style="display: none; padding: 12px; background: rgba(0, 122, 255, 0.1); border-radius: var(--border-radius); margin-bottom: 12px; border-left: 3px solid var(--accent);">
          <div style="font-size: 13px; color: var(--text-primary);">
            <strong>Selected:</strong> <span id="splitSelectedWordText"></span>
            <span id="splitSelectedWordTime" style="margin-left: 12px; color: var(--text-secondary);"></span>
          </div>
          <button type="button" id="splitClearSelection" class="btn btn-sm btn-secondary" style="margin-top: 8px;">Clear selection</button>
        </div>
        
        <!-- Fallback: word dropdown (if no word-level data) -->
        <div id="splitWordDropdown" style="display: none; margin-bottom: 12px;">
          <div style="color: var(--text-secondary); font-size: 13px; margin-bottom: 6px;">Select word to split at:</div>
          <select id="splitWordSelect" style="width: 100%; padding: 8px; border-radius: var(--border-radius); border: 1px solid var(--border);">
            <option value="">-- Select a word --</option>
          </select>
        </div>
        
        <!-- Speaker names -->
        <div style="display:grid; grid-template-columns: 1fr; gap: 10px;">
          <div>
            <div style="color: var(--text-secondary); font-size: 13px; margin-bottom: 6px;">Speaker name for first part (optional)</div>
            <input id="splitSpeakerA" type="text" placeholder="e.g., Carter" maxlength="100" />
          </div>
          <div>
            <div style="color: var(--text-secondary); font-size: 13px; margin-bottom: 6px;">Speaker name for second part (optional)</div>
            <input id="splitSpeakerB" type="text" placeholder="e.g., Mike" maxlength="100" />
          </div>
        </div>
        
        <!-- Existing splits indicator -->
        <div id="splitExistingSplits" style="display: none; margin-top: 12px; padding: 12px; background: rgba(255, 149, 0, 0.1); border-radius: var(--border-radius); border-left: 3px solid var(--warning);">
          <div style="font-size: 12px; color: var(--text-secondary);">
            <strong>Note:</strong> This utterance already has <span id="splitExistingCount">0</span> split(s). New split will be added.
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" id="splitCancelBtn">Cancel</button>
        <button type="button" class="btn btn-primary" id="splitSaveBtn" disabled>Save split</button>
      </div>
    </div>
  </div>

  <!-- Add Speakers Modal -->
  <div id="addSpeakersModal" class="modal-overlay" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Add Speakers</h3>
        <button type="button" class="btn btn-sm btn-secondary" id="addSpeakersCloseBtn">Close</button>
      </div>
      <div class="modal-body">
        <div style="color: var(--text-secondary); font-size: 13px; margin-bottom: 12px;">
          Add more speakers and re-run diarization. The system will re-analyze the audio to detect the new speaker count.
        </div>
        <div style="margin-bottom: 12px;">
          <label style="display: block; font-size: 13px; margin-bottom: 6px; font-weight: var(--font-weight-semibold);">
            How many speakers to add?
          </label>
          <input id="addSpeakersCount" type="number" min="1" max="10" value="1" style="width: 100%; padding: 8px; border-radius: var(--border-radius); border: 1px solid var(--border);" />
        </div>
        <div style="padding: 12px; background: var(--bg-secondary); border-radius: var(--border-radius); font-size: 12px; color: var(--text-secondary);">
          <strong>Current speakers:</strong> <span id="addSpeakersCurrentCount">0</span><br/>
          <strong>New total:</strong> <span id="addSpeakersNewTotal">0</span>
        </div>
        <div style="margin-top: 12px; padding: 10px; background: rgba(255, 149, 0, 0.1); border-radius: var(--border-radius); font-size: 11px; color: var(--text-secondary); border-left: 3px solid var(--warning);">
          ‚ö†Ô∏è This will re-run diarization and may take a few minutes. Your speaker name assignments will be cleared (you'll need to re-assign names).
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" id="addSpeakersCancelBtn">Cancel</button>
        <button type="button" class="btn btn-primary" id="addSpeakersConfirmBtn">Re-run Diarization</button>
      </div>
    </div>
  </div>

  <!-- Remove Speakers Modal -->
  <div id="removeSpeakersModal" class="modal-overlay" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Remove Speakers</h3>
        <button type="button" class="btn btn-sm btn-secondary" id="removeSpeakersCloseBtn">Close</button>
      </div>
      <div class="modal-body">
        <div style="color: var(--text-secondary); font-size: 13px; margin-bottom: 12px;">
          Reduce the number of speakers and re-run diarization. Use this if the system detected too many speakers.
        </div>
        <div style="margin-bottom: 12px;">
          <label style="display: block; font-size: 13px; margin-bottom: 6px; font-weight: var(--font-weight-semibold);">
            How many speakers to remove?
          </label>
          <input id="removeSpeakersCount" type="number" min="1" value="1" style="width: 100%; padding: 8px; border-radius: var(--border-radius); border: 1px solid var(--border);" />
        </div>
        <div style="padding: 12px; background: var(--bg-secondary); border-radius: var(--border-radius); font-size: 12px; color: var(--text-secondary);">
          <strong>Current speakers:</strong> <span id="removeSpeakersCurrentCount">0</span><br/>
          <strong>New total:</strong> <span id="removeSpeakersNewTotal">0</span>
        </div>
        <div style="margin-top: 12px; padding: 10px; background: rgba(255, 59, 48, 0.1); border-radius: var(--border-radius); font-size: 11px; color: var(--text-secondary); border-left: 3px solid var(--error);">
          ‚ö†Ô∏è This will re-run diarization and may take a few minutes. Your speaker name assignments will be cleared.
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" id="removeSpeakersCancelBtn">Cancel</button>
        <button type="button" class="btn btn-primary" id="removeSpeakersConfirmBtn" style="background: var(--error); border-color: var(--error);">Re-run Diarization</button>
      </div>
    </div>
  </div>

  <!-- Fixed Bottom Audio Player -->
  <div id="audioPlayerSection" class="audio-player-bottom">
    <div style="display: flex; align-items: center; gap: var(--space-md); margin-bottom: var(--space-sm);">
      <audio id="meetingAudio" controls style="flex: 1;">
        <source src="{{ audio_url }}" />
      </audio>
    </div>
    <div style="margin-top: var(--space-xs); color: var(--text-secondary); font-size: var(--font-size-xs);">
      <span id="normalModeTip">Tip: click any utterance to jump audio to that timestamp.</span>
    </div>
  </div>

  <script>
    const meetingId = {{ meeting_id|tojson }};
    const defaultDisplayByRaw = {};
    document.querySelectorAll('[data-speaker-input]').forEach((input) => {
      const raw = input.getAttribute('data-speaker-input');
      const def = input.getAttribute('data-default-display') || raw;
      defaultDisplayByRaw[raw] = def;
    });


    function toast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.style.display = 'block';
      setTimeout(() => { el.style.display = 'none'; }, 2800);
    }

    function currentLabelMap() {
      const map = {};
      document.querySelectorAll('[data-speaker-input]').forEach((input) => {
        const raw = input.getAttribute('data-speaker-input');
        const val = (input.value || '').trim();
        // Empty = clear mapping (revert to default)
        if (val) map[raw] = val;
      });
      return map;
    }

    function applyLabelMapToUI(map) {
      // Update chips
      document.querySelectorAll('[data-speaker-chip]').forEach((chip) => {
        const raw = chip.getAttribute('data-speaker-chip');
        const display = map[raw] || defaultDisplayByRaw[raw] || raw;
        const span = chip.querySelector('.speaker-display');
        if (span) span.textContent = display;
      });
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = String(text ?? '');
      return div.innerHTML;
    }

    // ============================================
    // Edit Text Mode - Inline transcript editing
    // ============================================
    function openEditTextMode(utteranceEl, editBtn) {
      const textDiv = utteranceEl.querySelector('.utterance-text');
      const utteranceId = utteranceEl.getAttribute('data-utterance-id');
      const originalText = textDiv.getAttribute('data-utterance-text') || '';
      
      // Check if already in edit mode
      if (textDiv.querySelector('.edit-mode-container')) return;
      
      // Store original content for cancel
      const originalContent = textDiv.innerHTML;
      
      // Create edit interface
      const editContainer = document.createElement('div');
      editContainer.className = 'edit-mode-container';
      editContainer.style.cssText = 'display: flex; flex-direction: column; gap: 8px;';
      
      const textarea = document.createElement('textarea');
      textarea.value = originalText;
      textarea.className = 'edit-textarea';
      textarea.style.cssText = `
        width: 100%;
        min-height: 80px;
        padding: 10px;
        border: 1px solid var(--border);
        border-radius: var(--border-radius);
        font-size: var(--font-size-sm);
        font-family: inherit;
        line-height: 1.5;
        resize: vertical;
        background: var(--bg-primary);
        color: var(--text-primary);
      `;
      textarea.addEventListener('click', (e) => e.stopPropagation());
      
      const buttonRow = document.createElement('div');
      buttonRow.style.cssText = 'display: flex; gap: 8px; justify-content: flex-end;';
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'btn btn-sm btn-secondary';
      cancelBtn.style.cssText = 'padding: 4px 12px;';
      cancelBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        textDiv.innerHTML = originalContent;
        editBtn.textContent = 'Edit';
        editBtn.disabled = false;
      });
      
      const saveBtn = document.createElement('button');
      saveBtn.textContent = 'Save';
      saveBtn.className = 'btn btn-sm btn-primary';
      saveBtn.style.cssText = 'padding: 4px 12px;';
      saveBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const newText = textarea.value.trim();
        
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
        cancelBtn.disabled = true;
        
        try {
          const resp = await fetch(`/api/meetings/${encodeURIComponent(meetingId)}/utterance_text`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ utterance_id: utteranceId, text: newText })
          });
          
          const data = await resp.json().catch(() => ({}));
          if (!resp.ok) throw new Error(data && (data.message || data.error) || 'Save failed');
          
          // Update the UI with new text
          textDiv.setAttribute('data-utterance-text', newText);
          textDiv.innerHTML = `<span class="normal-mode-text">${escapeHtml(newText)}</span>`;
          
          editBtn.textContent = 'Edit';
          editBtn.disabled = false;
          toast('Text saved. Transcript regenerated.');
        } catch (err) {
          toast(String(err.message || err));
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save';
          cancelBtn.disabled = false;
        }
      });
      
      buttonRow.appendChild(cancelBtn);
      buttonRow.appendChild(saveBtn);
      
      editContainer.appendChild(textarea);
      editContainer.appendChild(buttonRow);
      
      // Replace text content with edit interface
      textDiv.innerHTML = '';
      textDiv.appendChild(editContainer);
      
      // Update edit button
      editBtn.textContent = 'Editing...';
      editBtn.disabled = true;
      
      // Focus textarea
      textarea.focus();
      textarea.setSelectionRange(textarea.value.length, textarea.value.length);
    }

    function jumpAudioTo(startSeconds) {
      const audio = document.getElementById('meetingAudio');
      if (!audio) return;
      try {
        audio.currentTime = Math.max(0, startSeconds);
        audio.play();
      } catch (err) {
        // ignore autoplay restrictions
      }
    }

    // Undo split handler (called via event delegation)
    async function handleUndoSplit(btn) {
      const sourceId = btn.getAttribute('data-source-utterance-id');
      if (!sourceId) return;
      
      btn.disabled = true;
      btn.textContent = 'Undoing...';
      
      try {
        const resp = await fetch(`/api/meetings/${encodeURIComponent(meetingId)}/utterance_split/undo`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ source_utterance_id: sourceId })
        });
        
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data && (data.message || data.error) || 'Undo failed');
        
        // Find all split parts and replace with restored utterance
        const section = document.querySelector('section');
        const splitParts = Array.from(section.querySelectorAll(`[data-source-utterance-id="${sourceId}"]`));
        
        if (splitParts.length > 0 && data.restored_utterance) {
          const firstPart = splitParts[0];
          const newEl = buildUtteranceElement(data.restored_utterance);
          section.insertBefore(newEl, firstPart);
          
          // Remove all split parts
          splitParts.forEach(part => part.remove());
          
          // Update speaker chips if needed
          applyLabelMapToUI(currentLabelMap());
          
          toast('Split undone. Transcript/PDFs regenerated.');
        } else {
          window.location.reload();
        }
      } catch (e) {
        toast(String(e.message || e));
      } finally {
        btn.disabled = false;
        btn.textContent = 'Undo Split';
      }
    }

    function buildUtteranceElement(u) {
      const el = document.createElement('div');
      el.className = 'utterance';
      el.setAttribute('data-start', String(u.start ?? 0));
      el.setAttribute('data-end', String(u.end ?? 0));
      el.setAttribute('data-speaker-raw', String(u.speaker_raw ?? ''));
      el.setAttribute('data-utterance-id', String(u.utterance_id ?? ''));
      el.setAttribute('data-source-utterance-id', String(u.source_utterance_id ?? ''));
      const canSplit = String(u.utterance_id ?? '') === String(u.source_utterance_id ?? '');
      const hasWords = u.words && Array.isArray(u.words) && u.words.length > 0;

      // Build word mode text if words are available
      let textContent = '';
      if (hasWords) {
        const wordModeText = u.words.map((word, idx) => 
          `<span class="word-span" data-word-start="${word.start}" data-word-end="${word.end}" data-word-index="${idx}" title="${word.start.toFixed(2)}s - ${word.end.toFixed(2)}s">${escapeHtml(word.word)}</span>${idx < u.words.length - 1 ? ' ' : ''}`
        ).join('');
        textContent = `
          <span class="word-mode-text" style="display: none;">${wordModeText}</span>
          <span class="normal-mode-text">${escapeHtml(String(u.text ?? ''))}</span>
        `;
      } else {
        textContent = escapeHtml(String(u.text ?? ''));
      }

      el.innerHTML = `
        <div class="utterance-header">
          <div style="display:flex; align-items:center; gap: var(--space-sm); flex-wrap: wrap;">
            <div class="speaker-chip" data-speaker-chip="${escapeHtml(String(u.speaker_raw ?? ''))}">
              <span class="speaker-display">${escapeHtml(String(u.speaker_display ?? ''))}</span>
            </div>
            <div class="conf-badge" title="Approximate diarization confidence">
              Conf: <span class="conf-val">${escapeHtml(String(u.speaker_confidence_percent ?? 0))}%</span>
            </div>
          </div>
          <div class="utterance-actions">
            <div class="timestamp">${Number(u.start ?? 0).toFixed(1)}s</div>
            <button type="button" class="btn btn-sm btn-secondary utterance-edit-btn" title="Edit transcript text">Edit</button>
            <button type="button" class="btn btn-sm btn-secondary utterance-override-btn">New Speaker</button>
            ${canSplit ? `<button type="button" class="btn btn-sm btn-secondary utterance-split-btn">Split</button>` : `<button type="button" class="btn btn-sm btn-secondary utterance-add-split-btn" data-source-utterance-id="${escapeHtml(String(u.source_utterance_id ?? ''))}">Add Split</button><button type="button" class="btn btn-sm btn-secondary utterance-undo-split-btn" data-source-utterance-id="${escapeHtml(String(u.source_utterance_id ?? ''))}">Undo Split</button>`}
          </div>
        </div>
        <div class="utterance-text" style="white-space: pre-wrap;" data-utterance-text="${escapeHtml(String(u.text ?? ''))}" data-has-words="${hasWords ? 'true' : 'false'}">
          ${textContent}
        </div>
      `;
      // No need to attach handlers - using event delegation on section
      return el;
    }

    // EVENT DELEGATION - ONE set of listeners handles ALL utterances (prevents browser crash)
    const utteranceSection = document.querySelector('.transcript-layout > section');
    if (utteranceSection) {
      // Click handler for all utterance interactions
      utteranceSection.addEventListener('click', (e) => {
        // Handle Edit Text button
        const editBtn = e.target.closest('.utterance-edit-btn');
        if (editBtn) {
          e.stopPropagation();
          const utteranceEl = editBtn.closest('.utterance');
          if (utteranceEl) openEditTextMode(utteranceEl, editBtn);
          return;
        }
        
        // Handle New Speaker button
        const overrideBtn = e.target.closest('.utterance-override-btn');
        if (overrideBtn) {
          e.stopPropagation();
          const utteranceEl = overrideBtn.closest('.utterance');
          if (utteranceEl) openOverrideModal(utteranceEl);
          return;
        }
        
        // Handle Split button
        const splitBtn = e.target.closest('.utterance-split-btn');
        if (splitBtn) {
          e.stopPropagation();
          const utteranceEl = splitBtn.closest('.utterance');
          if (utteranceEl) openSplitModal(utteranceEl);
          return;
        }
        
        // Handle Add Split button
        const addSplitBtn = e.target.closest('.utterance-add-split-btn');
        if (addSplitBtn) {
          e.stopPropagation();
          const utteranceEl = addSplitBtn.closest('.utterance');
          if (utteranceEl) openSplitModal(utteranceEl);
          return;
        }
        
        // Handle Undo Split button
        const undoSplitBtn = e.target.closest('.utterance-undo-split-btn');
        if (undoSplitBtn) {
          e.stopPropagation();
          handleUndoSplit(undoSplitBtn);
          return;
        }
        
        // Handle speaker chip click (focus input)
        const chip = e.target.closest('[data-speaker-chip]');
        if (chip) {
          e.stopPropagation();
          const raw = chip.getAttribute('data-speaker-chip');
          const input = document.querySelector(`[data-speaker-input="${raw}"]`);
          if (input) input.focus();
          return;
        }
        
        // Handle utterance click (jump audio)
        const utteranceEl = e.target.closest('.utterance');
        if (utteranceEl) {
          const start = parseFloat(utteranceEl.getAttribute('data-start') || '0');
          jumpAudioTo(start);
        }
      });
    }

    // Live update labels across transcript as user types (DEBOUNCED to prevent lag)
    let labelUpdateTimeout = null;
    document.querySelectorAll('[data-speaker-input]').forEach((input) => {
      input.addEventListener('input', () => {
        // Debounce: wait 150ms after user stops typing before updating
        if (labelUpdateTimeout) clearTimeout(labelUpdateTimeout);
        labelUpdateTimeout = setTimeout(() => {
          applyLabelMapToUI(currentLabelMap());
        }, 150);
      });
    });

    document.getElementById('mergeHelpBtn').addEventListener('click', () => {
      toast('To merge speakers, set multiple raw labels to the same name, then Save.');
    });

    // Save labels
    document.getElementById('saveLabelsBtn').addEventListener('click', async () => {
      const labels = currentLabelMap();
      if (!Object.keys(labels).length) {
        toast('Nothing to save yet (enter at least one name).');
        return;
      }

      const btn = document.getElementById('saveLabelsBtn');
      btn.disabled = true;
      btn.textContent = 'Saving...';
      try {
        const resp = await fetch(`/api/meetings/${encodeURIComponent(meetingId)}/speaker_labels`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({labels})
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          throw new Error(data && (data.message || data.error) || 'Save failed');
        }
        toast('Saved. PDFs/transcript are regenerating.');
      } catch (e) {
        toast(String(e.message || e));
      } finally {
        btn.disabled = false;
        btn.textContent = 'Save speaker names';
      }
    });

    // Generate AI Summary button
    document.getElementById('generateAiSummaryBtn').addEventListener('click', async () => {
      const confirmed = confirm(
        '‚ö†Ô∏è Generate AI Summary?\n\n' +
        'This will use Ollama to create an AI-powered meeting summary.\n\n' +
        '‚Ä¢ May take 2-5 minutes depending on transcript length\n' +
        '‚Ä¢ Uses significant system resources (CPU/RAM)\n' +
        '‚Ä¢ Requires Ollama to be running locally\n\n' +
        'Continue?'
      );
      
      if (!confirmed) return;
      
      const btn = document.getElementById('generateAiSummaryBtn');
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = '‚è≥ Generating...';
      btn.style.opacity = '0.7';
      
      try {
        const resp = await fetch(`/api/meetings/${encodeURIComponent(meetingId)}/generate_summary`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'}
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          throw new Error(data && (data.message || data.error) || 'AI summary generation failed');
        }
        toast('‚úÖ AI Summary generated successfully! Refresh to see the updated PDF.');
        // Optionally reload to show updated PDF link
        setTimeout(() => window.location.reload(), 1500);
      } catch (e) {
        toast('‚ùå ' + String(e.message || e));
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
        btn.style.opacity = '1';
      }
    });

    // -------- Per-utterance "New Speaker" override --------
    const overrideModal = document.getElementById('overrideModal');
    const overrideInput = document.getElementById('overrideInput');
    let activeOverrideEl = null;

    function openOverrideModal(utteranceEl) {
      activeOverrideEl = utteranceEl;
      const currentName = utteranceEl.querySelector('.speaker-display')?.textContent || '';
      overrideInput.value = currentName.trim();
      overrideModal.style.display = 'flex';
      setTimeout(() => overrideInput.focus(), 50);
    }

    function closeOverrideModal() {
      overrideModal.style.display = 'none';
      activeOverrideEl = null;
    }

    document.getElementById('overrideCloseBtn').addEventListener('click', closeOverrideModal);
    document.getElementById('overrideCancelBtn').addEventListener('click', closeOverrideModal);
    overrideModal.addEventListener('click', (e) => { if (e.target === overrideModal) closeOverrideModal(); });

    document.getElementById('overrideSaveBtn').addEventListener('click', async () => {
      if (!activeOverrideEl) return;
      const utteranceId = activeOverrideEl.getAttribute('data-utterance-id');
      const speakerDisplay = (overrideInput.value || '').trim();
      const btn = document.getElementById('overrideSaveBtn');
      btn.disabled = true;
      btn.textContent = 'Saving...';
      try {
        const resp = await fetch(`/api/meetings/${encodeURIComponent(meetingId)}/utterance_overrides`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ utterance_id: utteranceId, speaker_display: speakerDisplay })
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data && (data.message || data.error) || 'Save failed');
        const updated = data.updated_utterance;
        const display = updated?.speaker_display ?? speakerDisplay;
        activeOverrideEl.querySelector('.speaker-display').textContent = display;
        
        // Add new speaker to sidebar if not already present
        if (display) {
          addSpeakerToSidebarIfNew(display);
        }
        
        toast('Saved. Transcript/PDFs regenerated.');
        closeOverrideModal();
      } catch (e) {
        toast(String(e.message || e));
      } finally {
        btn.disabled = false;
        btn.textContent = 'Save';
      }
    });
    
    // Helper function to add a speaker to the sidebar if they don't exist
    function addSpeakerToSidebarIfNew(speakerName) {
      if (!speakerName) return;
      const normalizedName = speakerName.trim().toLowerCase();
      
      // Check if this speaker already exists in the sidebar (by value in any input)
      const existingInputs = document.querySelectorAll('#speakerList .speaker-row input');
      for (const input of existingInputs) {
        const inputValue = (input.value || '').trim().toLowerCase();
        if (inputValue === normalizedName) {
          return; // Speaker already exists
        }
      }
      
      // Speaker doesn't exist - add a new row to the sidebar
      const speakerList = document.getElementById('speakerList');
      const newRow = document.createElement('div');
      newRow.className = 'speaker-row';
      newRow.setAttribute('data-speaker-raw', `override_${Date.now()}`);
      newRow.innerHTML = `
        <input
          type="text"
          value="${escapeHtml(speakerName)}"
          placeholder="Enter speaker name"
          data-speaker-input="override_${Date.now()}"
          data-default-display="${escapeHtml(speakerName)}"
        />
      `;
      speakerList.appendChild(newRow);
      
      // Also add to defaultDisplayByRaw so it can be used for matching
      defaultDisplayByRaw[`override_${Date.now()}`] = speakerName;
    }

    // -------- Split utterance at timestamp --------
    const splitModal = document.getElementById('splitModal');
    const splitTimeInput = document.getElementById('splitTimeInput');
    const splitSpeakerA = document.getElementById('splitSpeakerA');
    const splitSpeakerB = document.getElementById('splitSpeakerB');
    let activeSplitEl = null;

    let selectedSplitWordIndex = null;
    let selectedSplitWordTime = null;
    let currentSplitUtteranceWords = null;
    let currentSplitUtteranceText = null;

    function openSplitModal(utteranceEl) {
      // Allow splitting on any utterance (for multiple splits)
      activeSplitEl = utteranceEl;
      const sourceId = utteranceEl.getAttribute('data-source-utterance-id');
      const utteranceId = utteranceEl.getAttribute('data-utterance-id');
      const isOriginal = (utteranceId === sourceId);
      
      // Try to get full original utterance data if this is a split part
      if (!isOriginal) {
        // Find all parts with same source_utterance_id to reconstruct original
        const section = document.querySelector('section');
        const allParts = Array.from(section.querySelectorAll(`[data-source-utterance-id="${sourceId}"]`));
        
        // Sort by start time
        allParts.sort((a, b) => {
          const aStart = parseFloat(a.getAttribute('data-start') || '0');
          const bStart = parseFloat(b.getAttribute('data-start') || '0');
          return aStart - bStart;
        });
        
        // Reconstruct full text and words from all parts
        const fullTextParts = [];
        const fullWords = [];
        
        allParts.forEach(part => {
          const partTextEl = part.querySelector('.utterance-text');
          if (partTextEl) {
            const partText = partTextEl.getAttribute('data-utterance-text') || partTextEl.querySelector('.normal-mode-text')?.textContent || '';
            if (partText) fullTextParts.push(partText);
            
            // Get words from this part
            const wordSpans = partTextEl.querySelectorAll('.word-span');
            wordSpans.forEach(span => {
              fullWords.push({
                word: span.textContent.trim(),
                start: parseFloat(span.getAttribute('data-word-start') || '0'),
                end: parseFloat(span.getAttribute('data-word-end') || '0'),
                index: fullWords.length
              });
            });
          }
        });
        
        currentSplitUtteranceText = fullTextParts.join(' ');
        currentSplitUtteranceWords = fullWords.length > 0 ? fullWords : null;
      } else {
        // Original utterance - get data directly
        const textEl = utteranceEl.querySelector('.utterance-text');
        const hasWords = textEl && textEl.getAttribute('data-has-words') === 'true';
        
        currentSplitUtteranceText = textEl ? textEl.getAttribute('data-utterance-text') || textEl.querySelector('.normal-mode-text')?.textContent || '' : '';
        
        currentSplitUtteranceWords = null;
        if (hasWords && textEl) {
          const wordSpans = textEl.querySelectorAll('.word-span');
          if (wordSpans.length > 0) {
            currentSplitUtteranceWords = Array.from(wordSpans).map((span, idx) => ({
              word: span.textContent.trim(),
              start: parseFloat(span.getAttribute('data-word-start') || '0'),
              end: parseFloat(span.getAttribute('data-word-end') || '0'),
              index: idx
            }));
          }
        }
      }
      
      // Reset selection
      selectedSplitWordIndex = null;
      selectedSplitWordTime = null;
      splitSpeakerA.value = '';
      splitSpeakerB.value = '';
      
      // Render word selection interface
      renderSplitWordSelection();
      
      // Check for existing splits
      checkExistingSplits(sourceId);
      
      splitModal.style.display = 'flex';
    }
    
    function renderSplitWordSelection() {
      const container = document.getElementById('splitWordSelection');
      const selectedInfo = document.getElementById('splitSelectedWordInfo');
      const wordDropdown = document.getElementById('splitWordDropdown');
      const saveBtn = document.getElementById('splitSaveBtn');
      
      // Get sourceId for existing splits check
      const sourceId = activeSplitEl ? activeSplitEl.getAttribute('data-source-utterance-id') : '';
      const existingSplits = getExistingSplitIndices(sourceId);
      
      // Hide dropdown - we'll use sentence-style display for all cases
      wordDropdown.style.display = 'none';
      
      // Prepare words array - either from word-level data or from text
      let wordsArray = [];
      if (currentSplitUtteranceWords && currentSplitUtteranceWords.length > 0) {
        wordsArray = currentSplitUtteranceWords.map((word, idx) => ({
          word: word.word,
          index: idx,
          start: word.start,
          end: word.end,
          hasTimestamp: true
        }));
      } else if (currentSplitUtteranceText) {
        // Parse text into words when word-level data isn't available
        const textWords = currentSplitUtteranceText.split(/\s+/).filter(w => w.trim());
        wordsArray = textWords.map((word, idx) => ({
          word: word,
          index: idx,
          start: null,
          end: null,
          hasTimestamp: false
        }));
      }
      
      if (wordsArray.length > 0) {
        // Render clickable words as a natural sentence
        container.innerHTML = '';
        const wordsContainer = document.createElement('div');
        wordsContainer.style.cssText = 'font-size: 16px; line-height: 1.8; color: var(--text-primary); word-wrap: break-word;';
        
        // Build all word spans WITHOUT individual event listeners (prevents browser crash)
        wordsArray.forEach((wordData, idx) => {
          const span = document.createElement('span');
          span.className = 'split-word-option';
          span.textContent = wordData.word;
          
          // Check if this is an existing split point
          const isExistingSplit = existingSplits.includes(idx);
          
          // Base styling for natural sentence flow
          if (isExistingSplit) {
            // Existing split - visually distinct but not clickable
            span.style.cssText = 'display: inline; padding: 1px 2px; cursor: not-allowed; transition: all 0.2s; opacity: 0.5; text-decoration: line-through; color: var(--text-secondary);';
            span.title = 'Existing split point';
            span.setAttribute('data-existing-split', 'true');
          } else {
            // Clickable word - minimal styling for natural flow
            span.style.cssText = 'display: inline; padding: 1px 2px; cursor: pointer; transition: all 0.2s; border-radius: 2px;';
          }
          
          span.setAttribute('data-word-index', idx);
          span.setAttribute('data-word-text', wordData.word);
          if (wordData.hasTimestamp) {
            span.setAttribute('data-word-start', wordData.start);
            span.setAttribute('data-word-end', wordData.end);
          }
          
          wordsContainer.appendChild(span);
          // Add space after word (except for last word)
          if (idx < wordsArray.length - 1) {
            wordsContainer.appendChild(document.createTextNode(' '));
          }
        });
        
        // EVENT DELEGATION - ONE set of listeners handles ALL words (prevents browser crash)
        wordsContainer.addEventListener('mouseover', function(e) {
          const span = e.target.closest('.split-word-option');
          if (span && !span.classList.contains('split-word-selected') && span.getAttribute('data-existing-split') !== 'true') {
            span.style.backgroundColor = 'rgba(0, 122, 255, 0.15)';
            span.style.textDecoration = 'underline';
            span.style.textDecorationColor = 'rgba(0, 122, 255, 0.5)';
          }
        });
        
        wordsContainer.addEventListener('mouseout', function(e) {
          const span = e.target.closest('.split-word-option');
          if (span && !span.classList.contains('split-word-selected') && span.getAttribute('data-existing-split') !== 'true') {
            span.style.backgroundColor = '';
            span.style.textDecoration = '';
            span.style.textDecorationColor = '';
          }
        });
        
        wordsContainer.addEventListener('click', function(e) {
          const span = e.target.closest('.split-word-option');
          if (span && span.getAttribute('data-existing-split') !== 'true') {
            const idx = parseInt(span.getAttribute('data-word-index'), 10);
            const startAttr = span.getAttribute('data-word-start');
            const wordTime = startAttr ? parseFloat(startAttr) : null;
            const wordText = span.getAttribute('data-word-text');
            selectSplitWord(idx, wordTime, wordText);
          }
        });
        
        container.appendChild(wordsContainer);
      } else {
        container.innerHTML = '<div style="color: var(--text-error); font-size: 12px; text-align: center; padding: 20px;">Could not load utterance text.</div>';
      }
      
      selectedInfo.style.display = 'none';
      saveBtn.disabled = true;
    }
    
    function selectSplitWord(wordIndex, wordTime, wordText) {
      selectedSplitWordIndex = wordIndex;
      selectedSplitWordTime = wordTime;
      
      // Update UI - clear previous selection
      document.querySelectorAll('.split-word-option').forEach(el => {
        el.classList.remove('split-word-selected');
        // Reset to base styling
        if (el.style.cursor !== 'not-allowed') {
          el.style.backgroundColor = '';
          el.style.textDecoration = '';
          el.style.textDecorationColor = '';
          el.style.borderBottom = '';
          el.style.fontWeight = '';
        }
      });
      
      // Highlight selected word
      const selectedEl = document.querySelector(`.split-word-option[data-word-index="${wordIndex}"]`);
      if (selectedEl && selectedEl.style.cursor !== 'not-allowed') {
        selectedEl.classList.add('split-word-selected');
        selectedEl.style.backgroundColor = 'rgba(0, 122, 255, 0.2)';
        selectedEl.style.borderBottom = '2px solid var(--accent)';
        selectedEl.style.fontWeight = '600';
        selectedEl.style.textDecoration = '';
        selectedEl.style.textDecorationColor = '';
      }
      
      // Update selected info
      const selectedInfo = document.getElementById('splitSelectedWordInfo');
      const selectedText = document.getElementById('splitSelectedWordText');
      const selectedTime = document.getElementById('splitSelectedWordTime');
      
      selectedText.textContent = `"${wordText}" (word ${wordIndex + 1}) - split will occur before this word`;
      if (wordTime !== null) {
        selectedTime.textContent = `at ${wordTime.toFixed(2)}s`;
      } else {
        selectedTime.textContent = '';
      }
      
      selectedInfo.style.display = 'block';
      document.getElementById('splitSaveBtn').disabled = false;
    }
    
    function clearSplitSelection() {
      selectedSplitWordIndex = null;
      selectedSplitWordTime = null;
      document.getElementById('splitSelectedWordInfo').style.display = 'none';
      document.querySelectorAll('.split-word-option').forEach(el => {
        el.classList.remove('split-word-selected');
        // Reset styling but preserve existing split styling
        if (el.style.cursor !== 'not-allowed') {
          el.style.backgroundColor = '';
          el.style.textDecoration = '';
          el.style.textDecorationColor = '';
          el.style.borderBottom = '';
          el.style.fontWeight = '';
        }
      });
      document.getElementById('splitSaveBtn').disabled = true;
    }
    
    function getExistingSplitIndices(sourceId) {
      // Get existing split word indices by checking other parts
      // This is a simplified approach - in a real implementation, we'd fetch from the API
      const section = document.querySelector('section');
      const existingParts = Array.from(section.querySelectorAll(`[data-source-utterance-id="${sourceId}"]`));
      // For now, return empty array - we'll enhance this if needed
      // The backend validation will catch duplicate splits
      return [];
    }
    
    function checkExistingSplits(sourceId) {
      // Check if this utterance already has splits by looking for other parts
      const section = document.querySelector('section');
      const existingParts = Array.from(section.querySelectorAll(`[data-source-utterance-id="${sourceId}"]`));
      const existingCount = existingParts.length - 1; // Subtract 1 for the original/current part
      
      const existingSplitsDiv = document.getElementById('splitExistingSplits');
      const existingCountSpan = document.getElementById('splitExistingCount');
      
      if (existingCount > 0) {
        existingCountSpan.textContent = existingCount;
        existingSplitsDiv.style.display = 'block';
      } else {
        existingSplitsDiv.style.display = 'none';
      }
    }
    
    document.getElementById('splitClearSelection').addEventListener('click', clearSplitSelection);

    function closeSplitModal() {
      splitModal.style.display = 'none';
      activeSplitEl = null;
      clearSplitSelection();
      document.getElementById('splitWordSelection').innerHTML = '<div style="color: var(--text-secondary); font-size: 12px; text-align: center; padding: 20px;">Loading words...</div>';
      document.getElementById('splitExistingSplits').style.display = 'none';
    }

    document.getElementById('splitCloseBtn').addEventListener('click', closeSplitModal);
    document.getElementById('splitCancelBtn').addEventListener('click', closeSplitModal);
    splitModal.addEventListener('click', (e) => { if (e.target === splitModal) closeSplitModal(); });

    document.getElementById('splitSaveBtn').addEventListener('click', async () => {
      if (!activeSplitEl) return;
      if (selectedSplitWordIndex === null) {
        toast('Please select a word to split at.');
        return;
      }
      
      const sourceId = activeSplitEl.getAttribute('data-source-utterance-id');
      const aName = (splitSpeakerA.value || '').trim();
      const bName = (splitSpeakerB.value || '').trim();
      const btn = document.getElementById('splitSaveBtn');
      btn.disabled = true;
      btn.textContent = 'Saving...';
      
      try {
        const requestBody = {
          utterance_id: sourceId,
          split_word_index: selectedSplitWordIndex,
          speaker_display_a: aName,
          speaker_display_b: bName
        };
        
        // Include split_time if we have word-level data for better accuracy
        if (selectedSplitWordTime !== null) {
          requestBody.split_time = selectedSplitWordTime;
        }
        
        const resp = await fetch(`/api/meetings/${encodeURIComponent(meetingId)}/utterance_split`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(requestBody)
        });
        
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data && (data.message || data.error) || 'Split failed');
        
        const newUtts = data.new_utterances || [];
        if (newUtts.length > 0) {
          const parent = activeSplitEl.parentNode;
          const before = activeSplitEl;
          
          // Remove all existing parts of this split
          const existingParts = Array.from(parent.querySelectorAll(`[data-source-utterance-id="${sourceId}"]`));
          existingParts.forEach(part => {
            if (part !== activeSplitEl) part.remove();
          });
          
          // Insert all new parts
          newUtts.forEach((u) => {
            parent.insertBefore(buildUtteranceElement(u), before);
            // Add new speaker to sidebar if provided
            if (u.speaker_display) {
              addSpeakerToSidebarIfNew(u.speaker_display);
            }
          });
          parent.removeChild(activeSplitEl);
          
        } else {
          window.location.reload();
        }
        
        // Also add speakers from the input fields
        if (aName) addSpeakerToSidebarIfNew(aName);
        if (bName) addSpeakerToSidebarIfNew(bName);
        
        toast('Split saved. Transcript/PDFs regenerated.');
        closeSplitModal();
      } catch (e) {
        toast(String(e.message || e));
      } finally {
        btn.disabled = false;
        btn.textContent = 'Save split';
      }
    });

    // ============================================
    // Set Speakers Sidebar Sticky Top Position
    // ============================================
    (function() {
      const speakersAside = document.querySelector('.transcript-layout > aside');
      const header = document.querySelector('.header');
      
      if (speakersAside && header) {
        // Calculate header height dynamically
        const headerHeight = header.offsetHeight;
        // Set top position to be just below header with some padding
        speakersAside.style.top = (headerHeight + 16) + 'px';
        // Adjust max-height to account for header and bottom padding
        speakersAside.style.maxHeight = `calc(100vh - ${headerHeight + 32}px)`;
      }
    })();

    // ============================================
    // Add/Remove Speakers - Re-run Diarization
    // ============================================
    (function() {
      const addSpeakersBtn = document.getElementById('addSpeakersBtn');
      const removeSpeakersBtn = document.getElementById('removeSpeakersBtn');
      const addSpeakersModal = document.getElementById('addSpeakersModal');
      const removeSpeakersModal = document.getElementById('removeSpeakersModal');
      const rerunStatus = document.getElementById('rerunStatus');
      const rerunStatusText = document.getElementById('rerunStatusText');
      
      // Get current speaker count
      function getCurrentSpeakerCount() {
        return document.querySelectorAll('#speakerList .speaker-row').length;
      }
      
      // Update totals in modals
      function updateModalTotals() {
        const current = getCurrentSpeakerCount();
        
        // Add speakers modal
        document.getElementById('addSpeakersCurrentCount').textContent = current;
        const addCount = parseInt(document.getElementById('addSpeakersCount').value) || 1;
        document.getElementById('addSpeakersNewTotal').textContent = current + addCount;
        
        // Remove speakers modal
        document.getElementById('removeSpeakersCurrentCount').textContent = current;
        const removeCount = parseInt(document.getElementById('removeSpeakersCount').value) || 1;
        const removeMax = Math.max(1, current - 1);
        document.getElementById('removeSpeakersCount').max = removeMax;
        document.getElementById('removeSpeakersNewTotal').textContent = Math.max(1, current - removeCount);
      }
      
      // Open Add Speakers modal
      addSpeakersBtn.addEventListener('click', () => {
        updateModalTotals();
        addSpeakersModal.style.display = 'flex';
      });
      
      // Open Remove Speakers modal
      removeSpeakersBtn.addEventListener('click', () => {
        const current = getCurrentSpeakerCount();
        if (current <= 1) {
          toast('Cannot remove speakers: only 1 speaker remaining.');
          return;
        }
        updateModalTotals();
        removeSpeakersModal.style.display = 'flex';
      });
      
      // Close modals
      function closeAddModal() { addSpeakersModal.style.display = 'none'; }
      function closeRemoveModal() { removeSpeakersModal.style.display = 'none'; }
      
      document.getElementById('addSpeakersCloseBtn').addEventListener('click', closeAddModal);
      document.getElementById('addSpeakersCancelBtn').addEventListener('click', closeAddModal);
      addSpeakersModal.addEventListener('click', (e) => { if (e.target === addSpeakersModal) closeAddModal(); });
      
      document.getElementById('removeSpeakersCloseBtn').addEventListener('click', closeRemoveModal);
      document.getElementById('removeSpeakersCancelBtn').addEventListener('click', closeRemoveModal);
      removeSpeakersModal.addEventListener('click', (e) => { if (e.target === removeSpeakersModal) closeRemoveModal(); });
      
      // Update totals when input changes
      document.getElementById('addSpeakersCount').addEventListener('input', updateModalTotals);
      document.getElementById('removeSpeakersCount').addEventListener('input', updateModalTotals);
      
      // Re-run diarization
      async function rerunDiarization(newSpeakerCount) {
        // Show loading state
        rerunStatus.style.display = 'block';
        rerunStatusText.textContent = 'Re-running diarization...';
        addSpeakersBtn.disabled = true;
        removeSpeakersBtn.disabled = true;
        document.getElementById('saveLabelsBtn').disabled = true;
        
        try {
          const resp = await fetch(`/api/meetings/${encodeURIComponent(meetingId)}/rerun_diarization`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ num_speakers: newSpeakerCount, preserve_names: true })
          });
          
          const data = await resp.json().catch(() => ({}));
          
          if (!resp.ok) {
            throw new Error(data.error || data.message || 'Re-run failed');
          }
          
          // Success! Reload the page to show new results
          rerunStatusText.textContent = 'Complete! Reloading...';
          toast(`Diarization complete with ${newSpeakerCount} speakers. Reloading...`);
          
          // Small delay then reload
          setTimeout(() => {
            window.location.reload();
          }, 1000);
          
        } catch (e) {
          toast('Error: ' + (e.message || e));
          rerunStatus.style.display = 'none';
          addSpeakersBtn.disabled = false;
          removeSpeakersBtn.disabled = false;
          document.getElementById('saveLabelsBtn').disabled = false;
        }
      }
      
      // Confirm Add Speakers
      document.getElementById('addSpeakersConfirmBtn').addEventListener('click', () => {
        const current = getCurrentSpeakerCount();
        const addCount = parseInt(document.getElementById('addSpeakersCount').value) || 1;
        const newTotal = current + addCount;
        
        if (addCount < 1) {
          toast('Please enter a valid number of speakers to add.');
          return;
        }
        
        closeAddModal();
        rerunDiarization(newTotal);
      });
      
      // Confirm Remove Speakers
      document.getElementById('removeSpeakersConfirmBtn').addEventListener('click', () => {
        const current = getCurrentSpeakerCount();
        const removeCount = parseInt(document.getElementById('removeSpeakersCount').value) || 1;
        const newTotal = Math.max(1, current - removeCount);
        
        if (removeCount < 1) {
          toast('Please enter a valid number of speakers to remove.');
          return;
        }
        
        if (newTotal < 1) {
          toast('Cannot reduce to less than 1 speaker.');
          return;
        }
        
        closeRemoveModal();
        rerunDiarization(newTotal);
      });
    })();
  </script>
</body>
</html>

